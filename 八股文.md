# 操作系统

### 进程与线程

+ 进程是资源分配的基本单位，线程是资源调度的基本单位





























# C++

### 1. auto、auto& 和 const auto&

**auto :** `for(auto x:range)`会拷贝一份range元素，对x的操作不会修改range中的元素

```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
    vector<int> range={1,2,3,4,5};
    for(auto x:range){
        x=x+1;
    }
    return 0;
}
//range(1,2,3,4,5)
```

**auto& :** `for(auto& x:range)`修改了原容器中元素的值，&代表引用，不会拷贝

**auto&& :** `for(auto&& x:range)`也可以修改元素的值（一般用这种方法），不会拷贝

**const auto& :** `for(const auto& x:range)`只能读取range中的元素，不可修改

**const auto :** `for(const auto x:range)`只拷贝元素，不可修改拷贝出来的值

**Tips：auto的自动类型推断发生在编译期，所以使用auto并不会造成程序运行时效率的降低**



### 2. const

##### a. 作用

1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；**（没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰）**
4. 修饰成员函数，说明该成员函数内不能修改成员变量。

==记忆：被 const 修饰（在 const 后面）的值不可改变，p2、p3==

##### b. 使用

```c++
// 类
class A{
private:
    const int a;                // 常对象成员，可以使用初始化列表或者类内初始化
public:
    // 构造函数
    A() : a(0) { };
    A(int x) : a(x) { };        // 初始化列表

    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值
};

void function(){
    // 对象
    A b;                        // 普通对象，可以调用全部成员函数
    const A a;                  // 常对象，只能调用常成员函数
    const A *p = &a;            // 指针变量，指向常对象
    const A &q = a;             // 指向常对象的引用

    // 指针
    char greeting[] = "Hello";
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）
    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）
    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量
}

// 函数
void function1(const int Var);           // 传递过来的参数在函数内不可变
void function2(const char* Var);         // 参数指针所指内容为常量
void function3(char* const Var);         // 参数指针为常量
void function4(const int& Var);          // 引用参数在函数内为常量

// 函数返回值
const int function5();      // 返回一个常数
const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();
int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();
```



### 3. 宏定义 #define 和 const 常量

|    宏定义 #define    |   const 常量   |
| :------------------: | :------------: |
|    相当于字符替换    |    常量声明    |
|     预处理器处理     |   编译器处理   |
|    无类型安全检查    | 有类型安全检查 |
|      不分配内存      |   要分配内存   |
|     存储在代码段     |  存储在数据段  |
| 可通过 `#undef` 取消 |    不可取消    |

**预处理器：真正的编译开始之前由编译器调用的独立程序**

**类型安全：访问可以被授权访问的内存位置**



### 4. static

1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
2. 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。



























### 结构体内存对齐

- 结构体内成员按照声明顺序存储

- 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐）

- 结构体的内存大小为**有效对齐值**的整数倍，不足的需要补齐

- 当结构体嵌套了结构体时，作为数据成员的结构体的自身长度作为外部结构体的最大成员的内存大小，比如结构体a嵌套结构体b，b中有char、int、double等，则b的自身长度为8

  ```c++
  /**
  * 0 1   3     6   8 9            15
  * +-+---+-----+---+-+-------------+
  * | |   |     |   | |             |
  * |a| b |  c  | d |e|     pad     |
  * | |   |     |   | |             |
  * +-+---+-----+---+-+-------------+
  */
  ```

  

  **==目的==：** 
  
  **a. 程序的执行效率提高** （一般情况，CPU以字节大小（32位处理器4个字节）访问数据，如果数据没有内存对齐，CPU访问这些数据时，可能需要执行多次的读取操作，为了让CPU能一次获取到数据，从而提升性能）
  
  **b. 访问范围提高** 
  
  **c. 原子性的保障** （CPU 每次访问数据的宽度是一个字，要么完整地被执行,要么完全不执行）

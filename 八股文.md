# 计算机网络

### 1. TCP首部格式

![TCP首部](Pics/TCP首部.png)

- 序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。假设A -> B且ISN = 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。
- 确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1。
- 首部长（4bit）：标识首部有多少个4字节 * 首部长，最大为15，即60字节。
- 标志位（6bit）：
  - URG：标志紧急指针是否有效。
  - ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。
  - PSH：提示接收端立即从缓冲读走数据。
  - RST：表示要求对方重新建立连接（复位报文段）。
  - SYN：表示请求建立一个连接（连接报文段）。
  - FIN：表示关闭连接（断开报文段）。
- 窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。
- 校验和（16bit）：接收端用CRC检验整个报文段有无损坏。



### 2. UDP首部格式

### 3. IP

# 操作系统

### 进程与线程

+ 进程是资源分配的基本单位，线程是资源调度的基本单位





























# C++

### 1. auto、auto& 和 const auto&

**auto :** `for(auto x:range)`会拷贝一份range元素，对x的操作不会修改range中的元素

```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
    vector<int> range={1,2,3,4,5};
    for(auto x:range){
        x=x+1;
    }
    return 0;
}
//range(1,2,3,4,5)
```

**auto& :** `for(auto& x:range)`修改了原容器中元素的值，&代表引用，不会拷贝

**auto&& :** `for(auto&& x:range)`也可以修改元素的值（一般用这种方法），不会拷贝

**const auto& :** `for(const auto& x:range)`只能读取range中的元素，不可修改

**const auto :** `for(const auto x:range)`只拷贝元素，不可修改拷贝出来的值

**Tips：auto的自动类型推断发生在编译期，所以使用auto并不会造成程序运行时效率的降低**



### 2. const

##### a. 作用

1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；**（没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰）**
4. 修饰成员函数，说明该成员函数内不能修改成员变量。

==记忆：被 const 修饰（在 const 后面）的值不可改变，p2、p3==

##### b. 使用

```c++
// 类
class A{
private:
    const int a;                // 常对象成员，可以使用初始化列表或者类内初始化
public:
    // 构造函数
    A() : a(0) { };
    A(int x) : a(x) { };        // 初始化列表

    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值
};

void function(){
    // 对象
    A b;                        // 普通对象，可以调用全部成员函数
    const A a;                  // 常对象，只能调用常成员函数
    const A *p = &a;            // 指针变量，指向常对象
    const A &q = a;             // 指向常对象的引用

    // 指针
    char greeting[] = "Hello";
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）
    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）
    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量
}

// 函数
void function1(const int Var);           // 传递过来的参数在函数内不可变
void function2(const char* Var);         // 参数指针所指内容为常量
void function3(char* const Var);         // 参数指针为常量
void function4(const int& Var);          // 引用参数在函数内为常量

// 函数返回值
const int function5();      // 返回一个常数
const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();
int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();
```



### 3. 宏定义 #define 和 const 常量

|    宏定义 #define    |   const 常量   |
| :------------------: | :------------: |
|    相当于字符替换    |    常量声明    |
|     预处理器处理     |   编译器处理   |
|    无类型安全检查    | 有类型安全检查 |
|      不分配内存      |   要分配内存   |
|     存储在代码段     |  存储在数据段  |
| 可通过 `#undef` 取消 |    不可取消    |

**预处理器：真正的编译开始之前由编译器调用的独立程序**

**类型安全：访问可以被授权访问的内存位置**



### 4. static

1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，**在 main 函数运行前就分配了空间**，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
2. 修饰普通函数，**表明函数的作用范围，仅在定义该函数的文件内才能使用**。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
3. 修饰成员变量，**修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员**。
4. 修饰成员函数，**修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员**。



### 5. this指针

1. `this` 指针是一个隐含于每一个**非静态成员函数**中的特殊指针，它指向调用该成员函数的那个对象。
2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。
3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
4. `this` 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName* const`，这说明 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
5. `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。
6. 在以下场景中，经常需要显式引用`this`指针：
   1. 为实现对象的链式引用；
   2. 为避免对同一对象进行赋值操作；
   3. 在实现一些数据结构时，如 `list`。



### 6. inline 内联函数

##### a. 特征

- 相当于把内联函数里面的内容写在调用内联函数处；
- **相当于不用执行进入函数的步骤，直接执行函数体**；
- 相当于宏，却比宏多了类型检查，真正具有函数特性；
- 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
- 在类声明中**定义**的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

##### b. 使用

```c++
// 声明1（加 inline，建议使用）
inline int functionName(int first, int second,...);

// 声明2（不加 inline）
int functionName(int first, int second,...);

// 定义
inline int functionName(int first, int second,...) {/****/};

// 类内定义，隐式内联
class A {
    int doA() { return 0; }         // 隐式内联
}

// 类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联
```

##### c. 优点

1. 内联函数同宏函数一样将**在被调用处进行代码展开**，**省去了参数压栈、栈帧开辟与回收，结果返回等**，从而提高程序运行速度；
2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会；
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能；
4. 内联函数在运行时可调试，而宏定义不可以。

##### d. 缺点

1. **代码膨胀**。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. **inline 函数无法随着函数库升级而升级**。inline函数的改变需要重新编译，不像 non-inline 可以直接链接；
3. 是否内联，**程序员不可控**。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

> **虚函数（virtual）可以是内联函数（inline）吗？**
>
> - 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联
> - 内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联
> - `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生

```c++
#include <iostream>  
using namespace std;
class Base
{
public:
	inline virtual void who()
	{
		cout << "I am Base\n";
	}
	virtual ~Base() {}
};
class Derived : public Base
{
public:
	inline void who()  // 不写inline时隐式内联
	{
		cout << "I am Derived\n";
	}
};

int main()
{
	// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
	Base b;
	b.who();

	// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
	Base *ptr = new Derived();
	ptr->who();

	// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
	delete ptr;
	ptr = nullptr;

	system("pause");
	return 0;
} 
```



### 7. volatile

```
volatile int i = 10; 
```

- volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以**使用 volatile 告诉编译器不应对这样的对象进行优化**。
- volatile 关键字声明的变量，**每次访问时都必须从内存中取出值**（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
- const 可以是 volatile （如只读的状态寄存器）
- 指针可以是 volatile



### 8. assert()

断言，是宏，而非函数。

assert 宏的原型定义在 `<assert.h>`（C）、`<cassert>`（C++）中，**其作用是如果它的条件返回错误，则终止程序执行**。

可以通过定义 `NDEBUG` 来关闭 assert，但是需要在源代码的开头，`include <assert.h>` 之前。

```c++
#define NDEBUG          // 加上这行，则 assert 不可用
#include <assert.h>

assert( p != NULL );    // assert 不可用
```



### 9. sizeof()

- sizeof 对数组，得到整个数组所占空间大小
- sizeof 对指针，得到指针本身所占空间大小



### 10. #pragma pack(n)

设定结构体、联合以及类成员变量以 n 字节方式对齐

```c++
#pragma pack(push)  // 保存对齐状态
#pragma pack(4)     // 设定为 4 字节对齐

struct test
{
    char m1; 			//(1)+3
    double m4;   	//(8)
    int m3;				//(4)
};

#pragma pack(pop)   // 恢复对齐状态
```



### 11. 结构体内存对齐

- 结构体内成员按照声明顺序存储

- 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐）

- 结构体的内存大小为**有效对齐值**的整数倍，不足的需要补齐

- 当结构体嵌套了结构体时，作为数据成员的结构体的自身长度作为外部结构体的最大成员的内存大小，比如结构体a嵌套结构体b，b中有char、int、double等，则b的自身长度为8

  ```c++
  /**
  * 0 1   3     6   8 9            15
  * +-+---+-----+---+-+-------------+
  * | |   |     |   | |             |
  * |a| b |  c  | d |e|     pad     |
  * | |   |     |   | |             |
  * +-+---+-----+---+-+-------------+
  */
  ```

  

  **==目的==：** 
  
  **a. 程序的执行效率提高** （一般情况，CPU以字节大小（32位处理器4个字节）访问数据，如果数据没有内存对齐，CPU访问这些数据时，可能需要执行多次的读取操作，为了让CPU能一次获取到数据，从而提升性能）
  
  **b. 访问范围提高** 
  
  **c. 原子性的保障** （CPU 每次访问数据的宽度是一个字，要么完整地被执行,要么完全不执行）
